/*****************************************************************************

Copyright (c) 1996, 2015, Oracle and/or its affiliates. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA

*****************************************************************************/

/**************************************************//**
@file include/btr0pcur.ic
The index tree persistent cursor

Created 2/23/1996 Heikki Tuuri
*******************************************************/


/*********************************************************//**
Gets the rel_pos field for a cursor whose position has been stored.
@return BTR_PCUR_ON, ... */
UNIV_INLINE
ulint
btr_pcur_get_rel_pos(
/*=================*/
	const btr_pcur_t*	cursor)	/*!< in: persistent cursor */
{
	ut_ad(cursor);
	ut_ad(cursor->old_rec);
	ut_ad(cursor->old_stored);
	ut_ad(cursor->pos_state == BTR_PCUR_WAS_POSITIONED
	      || cursor->pos_state == BTR_PCUR_IS_POSITIONED);

	return(cursor->rel_pos);
}

#ifdef UNIV_DEBUG
/*********************************************************//**
Returns the btr cursor component of a persistent cursor.
@return pointer to btr cursor component */
UNIV_INLINE
btr_cur_t*
btr_pcur_get_btr_cur(
/*=================*/
	const btr_pcur_t*	cursor)	/*!< in: persistent cursor */
{
	const btr_cur_t*	btr_cur = &cursor->btr_cur;
	return((btr_cur_t*) btr_cur);
}

/*********************************************************//**
Returns the page cursor component of a persistent cursor.
@return pointer to page cursor component */
UNIV_INLINE
page_cur_t*
btr_pcur_get_page_cur(
/*==================*/
	const btr_pcur_t*	cursor)	/*!< in: persistent cursor */
{
	return(btr_cur_get_page_cur(btr_pcur_get_btr_cur(cursor)));
}

/*********************************************************//**
Returns the page of a persistent cursor.
@return pointer to the page */
UNIV_INLINE
page_t*
btr_pcur_get_page(
/*==============*/
	const btr_pcur_t*	cursor)	/*!< in: persistent cursor */
{
	ut_ad(cursor->pos_state == BTR_PCUR_IS_POSITIONED);

	return(btr_cur_get_page(btr_pcur_get_btr_cur(cursor)));
}

/*********************************************************//**
Returns the buffer block of a persistent cursor.
@return pointer to the block */
UNIV_INLINE
buf_block_t*
btr_pcur_get_block(
/*===============*/
	const btr_pcur_t*	cursor)	/*!< in: persistent cursor */
{
	ut_ad(cursor->pos_state == BTR_PCUR_IS_POSITIONED);

	return(btr_cur_get_block(btr_pcur_get_btr_cur(cursor)));
}

/*********************************************************//**
Returns the record of a persistent cursor.
@return pointer to the record */
UNIV_INLINE
rec_t*
btr_pcur_get_rec(
/*=============*/
	const btr_pcur_t*	cursor)	/*!< in: persistent cursor */
{
	ut_ad(cursor->pos_state == BTR_PCUR_IS_POSITIONED);
	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);

	return(btr_cur_get_rec(btr_pcur_get_btr_cur(cursor)));
}
#endif /* UNIV_DEBUG */

/**************************************************************//**
Gets the up_match value for a pcur after a search.
@return number of matched fields at the cursor or to the right if
search mode was PAGE_CUR_GE, otherwise undefined */
UNIV_INLINE
ulint
btr_pcur_get_up_match(
/*==================*/
	const btr_pcur_t*	cursor) /*!< in: persistent cursor */
{
	const btr_cur_t*	btr_cursor;

	ut_ad((cursor->pos_state == BTR_PCUR_WAS_POSITIONED)
	      || (cursor->pos_state == BTR_PCUR_IS_POSITIONED));

	btr_cursor = btr_pcur_get_btr_cur(cursor);

	ut_ad(btr_cursor->up_match != ULINT_UNDEFINED);

	return(btr_cursor->up_match);
}

/**************************************************************//**
Gets the low_match value for a pcur after a search.
@return number of matched fields at the cursor or to the right if
search mode was PAGE_CUR_LE, otherwise undefined */
UNIV_INLINE
ulint
btr_pcur_get_low_match(
/*===================*/
	const btr_pcur_t*	cursor) /*!< in: persistent cursor */
{
	const btr_cur_t*	btr_cursor;

	ut_ad((cursor->pos_state == BTR_PCUR_WAS_POSITIONED)
	      || (cursor->pos_state == BTR_PCUR_IS_POSITIONED));

	btr_cursor = btr_pcur_get_btr_cur(cursor);
	ut_ad(btr_cursor->low_match != ULINT_UNDEFINED);

	return(btr_cursor->low_match);
}

/*********************************************************//**
Checks if the persistent cursor is after the last user record on
a page. */
UNIV_INLINE
ibool
btr_pcur_is_after_last_on_page(
/*===========================*/
	const btr_pcur_t*	cursor)	/*!< in: persistent cursor */
{
	ut_ad(cursor->pos_state == BTR_PCUR_IS_POSITIONED);
	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);

	return(page_cur_is_after_last(btr_pcur_get_page_cur(cursor)));
}

/*********************************************************//**
Checks if the persistent cursor is before the first user record on
a page. */
UNIV_INLINE
ibool
btr_pcur_is_before_first_on_page(
/*=============================*/
	const btr_pcur_t*	cursor)	/*!< in: persistent cursor */
{
	ut_ad(cursor->pos_state == BTR_PCUR_IS_POSITIONED);
	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);

	return(page_cur_is_before_first(btr_pcur_get_page_cur(cursor)));
}

/*********************************************************//**
Checks if the persistent cursor is on a user record. */
UNIV_INLINE
ibool
btr_pcur_is_on_user_rec(
/*====================*/
	const btr_pcur_t*	cursor)	/*!< in: persistent cursor */
{
	ut_ad(cursor->pos_state == BTR_PCUR_IS_POSITIONED);
	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);

	if (btr_pcur_is_before_first_on_page(cursor)
	    || btr_pcur_is_after_last_on_page(cursor)) {

		return(FALSE);
	}

	return(TRUE);
}

/*********************************************************//**
Checks if the persistent cursor is before the first user record in
the index tree. */
UNIV_INLINE
ibool
btr_pcur_is_before_first_in_tree(
/*=============================*/
	btr_pcur_t*	cursor,	/*!< in: persistent cursor */
	mtr_t*		mtr)	/*!< in: mtr */
{
	ut_ad(cursor->pos_state == BTR_PCUR_IS_POSITIONED);
	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);

	if (btr_page_get_prev(btr_pcur_get_page(cursor), mtr) != FIL_NULL) {

		return(FALSE);
	}

	return(page_cur_is_before_first(btr_pcur_get_page_cur(cursor)));
}

/*********************************************************//**
Checks if the persistent cursor is after the last user record in
the index tree. */
UNIV_INLINE
ibool
btr_pcur_is_after_last_in_tree(
/*===========================*/
	btr_pcur_t*	cursor,	/*!< in: persistent cursor */
	mtr_t*		mtr)	/*!< in: mtr */
{
	ut_ad(cursor->pos_state == BTR_PCUR_IS_POSITIONED);
	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);

	if (btr_page_get_next(btr_pcur_get_page(cursor), mtr) != FIL_NULL) {

		return(FALSE);
	}

	return(page_cur_is_after_last(btr_pcur_get_page_cur(cursor)));
}

/*********************************************************//**
Moves the persistent cursor to the next record on the same page. */
UNIV_INLINE
void
btr_pcur_move_to_next_on_page(
/*==========================*/
	btr_pcur_t*	cursor)	/*!< in/out: persistent cursor */
{
	ut_ad(cursor->pos_state == BTR_PCUR_IS_POSITIONED);
	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);

	page_cur_move_to_next(btr_pcur_get_page_cur(cursor));

	cursor->old_stored = false;
}

/*********************************************************//**
Moves the persistent cursor to the previous record on the same page. */
UNIV_INLINE
void
btr_pcur_move_to_prev_on_page(
/*==========================*/
	btr_pcur_t*	cursor)	/*!< in/out: persistent cursor */
{
	ut_ad(cursor->pos_state == BTR_PCUR_IS_POSITIONED);
	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);

	page_cur_move_to_prev(btr_pcur_get_page_cur(cursor));

	cursor->old_stored = false;
}

/*********************************************************//**
Moves the persistent cursor to the last record on the same page. */
UNIV_INLINE
void
btr_pcur_move_to_last_on_page(
/*==========================*/
	btr_pcur_t*	cursor,	/*!< in: persistent cursor */
	mtr_t*		mtr)	/*!< in: mtr */
{
	UT_NOT_USED(mtr);
	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);

	page_cur_set_after_last(btr_pcur_get_block(cursor),
				btr_pcur_get_page_cur(cursor));

	cursor->old_stored = false;
}

/*********************************************************//**
Moves the persistent cursor to the next user record in the tree. If no user
records are left, the cursor ends up 'after last in tree'.
@return TRUE if the cursor moved forward, ending on a user record */
UNIV_INLINE
ibool
btr_pcur_move_to_next_user_rec(
/*===========================*/
	btr_pcur_t*	cursor,	/*!< in: persistent cursor; NOTE that the
				function may release the page latch */
	mtr_t*		mtr)	/*!< in: mtr */
{
	ut_ad(cursor->pos_state == BTR_PCUR_IS_POSITIONED);
	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);
	cursor->old_stored = false;
loop:
	if (btr_pcur_is_after_last_on_page(cursor)) {

		if (btr_pcur_is_after_last_in_tree(cursor, mtr)) {

			return(FALSE);
		}

		btr_pcur_move_to_next_page(cursor, mtr);
	} else {
		btr_pcur_move_to_next_on_page(cursor);
	}

	if (btr_pcur_is_on_user_rec(cursor)) {

		return(TRUE);
	}

	goto loop;
}

/*********************************************************//**
Moves the persistent cursor to the next record in the tree. If no records are
left, the cursor stays 'after last in tree'.
@return TRUE if the cursor was not after last in tree */
UNIV_INLINE
ibool
btr_pcur_move_to_next(
/*==================*/
	btr_pcur_t*	cursor,	/*!< in: persistent cursor; NOTE that the
				function may release the page latch */
	mtr_t*		mtr)	/*!< in: mtr */
{
	ut_ad(cursor->pos_state == BTR_PCUR_IS_POSITIONED);
	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);

	cursor->old_stored = false;

	if (btr_pcur_is_after_last_on_page(cursor)) {

		if (btr_pcur_is_after_last_in_tree(cursor, mtr)) {

			return(FALSE);
		}

		btr_pcur_move_to_next_page(cursor, mtr);

		return(TRUE);
	}

	btr_pcur_move_to_next_on_page(cursor);

	return(TRUE);
}

/**************************************************************//**
Commits the mtr and sets the pcur latch mode to BTR_NO_LATCHES,
that is, the cursor becomes detached.
Function btr_pcur_store_position should be used before calling this,
if restoration of cursor is wanted later. */
UNIV_INLINE
void
btr_pcur_commit_specify_mtr(
/*========================*/
	btr_pcur_t*	pcur,	/*!< in: persistent cursor */
	mtr_t*		mtr)	/*!< in: mtr to commit */
{
	ut_ad(pcur->pos_state == BTR_PCUR_IS_POSITIONED);

	pcur->latch_mode = BTR_NO_LATCHES;

	mtr_commit(mtr);

	pcur->pos_state = BTR_PCUR_WAS_POSITIONED;
}

/**************************************************************//**
Sets the old_rec_buf field to NULL. */
UNIV_INLINE
void
btr_pcur_init(
/*==========*/
	btr_pcur_t*	pcur)	/*!< in: persistent cursor */
{
	pcur->old_stored = false;
	pcur->old_rec_buf = NULL;
	pcur->old_rec = NULL;

	pcur->btr_cur.rtr_info = NULL;
}

/** Free old_rec_buf.
@param[in]	pcur	Persistent cursor holding old_rec to be freed. */
UNIV_INLINE
void
btr_pcur_free(
	btr_pcur_t*	pcur)
{
	ut_free(pcur->old_rec_buf);
}

/**************************************************************//**
Initializes and opens a persistent cursor to an index tree. It should be
closed with btr_pcur_close. */
UNIV_INLINE
void
btr_pcur_open_low(
/*==============*/
	dict_index_t*	index,	/*!< in: index */
	ulint		level,	/*!< in: level in the btree */
	const dtuple_t*	tuple,	/*!< in: tuple on which search done */
	page_cur_mode_t	mode,	/*!< in: PAGE_CUR_L, ...;
				NOTE that if the search is made using a unique
				prefix of a record, mode should be
				PAGE_CUR_LE, not PAGE_CUR_GE, as the latter
				may end up on the previous page from the
				record! */
	ulint		latch_mode,/*!< in: BTR_SEARCH_LEAF, ... */
	btr_pcur_t*	cursor, /*!< in: memory buffer for persistent cursor */
	const char*	file,	/*!< in: file name */
	ulint		line,	/*!< in: line where called */
	mtr_t*		mtr)	/*!< in: mtr */
{
	btr_cur_t*	btr_cursor;

	/* Initialize the cursor */

	btr_pcur_init(cursor);

	cursor->latch_mode = BTR_LATCH_MODE_WITHOUT_FLAGS(latch_mode);
	cursor->search_mode = mode;

	/* Search with the tree cursor */

	btr_cursor = btr_pcur_get_btr_cur(cursor);

	ut_ad(!dict_index_is_spatial(index));

	if (dict_table_is_intrinsic(index->table)) {
		ut_ad((latch_mode & BTR_MODIFY_LEAF)
		      || (latch_mode & BTR_SEARCH_LEAF)
		      || (latch_mode & BTR_MODIFY_TREE));
		btr_cur_search_to_nth_level_with_no_latch(
			index, level, tuple, mode, btr_cursor,
			file, line, mtr,
			(((latch_mode & BTR_MODIFY_LEAF)
			 || (latch_mode & BTR_MODIFY_TREE)) ? true : false));
	} else {
		btr_cur_search_to_nth_level(
			index, level, tuple, mode, latch_mode,
			btr_cursor, 0, file, line, mtr);
	}

	cursor->pos_state = BTR_PCUR_IS_POSITIONED;

	cursor->trx_if_known = NULL;
}

/**************************************************************//**
Opens an persistent cursor to an index tree without initializing the
cursor. */
UNIV_INLINE
void
btr_pcur_open_with_no_init_func(
/*============================*/
	dict_index_t*	index,	/*!< in: index */
	const dtuple_t*	tuple,	/*!< in: tuple on which search done */
	page_cur_mode_t	mode,	/*!< in: PAGE_CUR_L, ...;
				NOTE that if the search is made using a unique
				prefix of a record, mode should be
				PAGE_CUR_LE, not PAGE_CUR_GE, as the latter
				may end up on the previous page of the
				record! */
	ulint		latch_mode,/*!< in: BTR_SEARCH_LEAF, ...;
				NOTE that if has_search_latch != 0 then
				we maybe do not acquire a latch on the cursor
				page, but assume that the caller uses his
				btr search latch to protect the record! */
	btr_pcur_t*	cursor, /*!< in: memory buffer for persistent cursor */
	ulint		has_search_latch,
				/*!< in: latch mode the caller
				currently has on search system:
				RW_S_LATCH, or 0 */
	const char*	file,	/*!< in: file name */
	ulint		line,	/*!< in: line where called */
	mtr_t*		mtr)	/*!< in: mtr */
{

//cgmin
DBUG_ENTER("cgmin btr_pcur_open_with_no_init_func");

	btr_cur_t*	btr_cursor;

	cursor->latch_mode = BTR_LATCH_MODE_WITHOUT_INTENTION(latch_mode);
	cursor->search_mode = mode;

	/* Search with the tree cursor */

	btr_cursor = btr_pcur_get_btr_cur(cursor);

	if (dict_table_is_intrinsic(index->table)) {
		ut_ad((latch_mode & BTR_MODIFY_LEAF)
		      || (latch_mode & BTR_SEARCH_LEAF));
		btr_cur_search_to_nth_level_with_no_latch(
			index, 0, tuple, mode, btr_cursor,
			file, line, mtr,
			((latch_mode & BTR_MODIFY_LEAF) ? true : false));
	} else {
		btr_cur_search_to_nth_level(
			index, 0, tuple, mode, latch_mode, btr_cursor,
			has_search_latch, file, line, mtr);
	}

	cursor->pos_state = BTR_PCUR_IS_POSITIONED;

	cursor->old_stored = false;

	cursor->trx_if_known = NULL;

DBUG_VOID_RETURN;
}

//cgmin
#if 0 
void set_pcur_pos_pio_func(int pio_t,btr_pcur_t* pcur_pio,int* page_id_pio,btr_pcur_t* temp_pcur_pio,
	bool		from_left,	/*!< in: true if open to the low end,
					false if to the high end */
	dict_index_t*	index,		/*!< in: index */
	ulint		latch_mode,	/*!< in: latch mode */
	btr_cur_t*	cursor,		/*!< in/out: cursor */
	ulint		level,		/*!< in: level to search for
					(0=leaf). */
	const char*	file,		/*!< in: file name */
	ulint		line,		/*!< in: line where called */
	mtr_t*		mtr)		/*!< in/out: mini-transaction */
{
	page_cur_t*	page_cursor;
	ulint		node_ptr_max_size = UNIV_PAGE_SIZE / 2;
	ulint		height;
	ulint		root_height = 0; /* remove warning */
	rec_t*		node_ptr;
	ulint		estimate;
	ulint		savepoint;
	ulint		upper_rw_latch, root_leaf_rw_latch;
	btr_intention_t	lock_intention;
	buf_block_t*	tree_blocks[BTR_MAX_LEVELS];
	ulint		tree_savepoints[BTR_MAX_LEVELS];
	ulint		n_blocks = 0;
	ulint		n_releases = 0;
	mem_heap_t*	heap		= NULL;
	ulint		offsets_[REC_OFFS_NORMAL_SIZE];
	ulint*		offsets		= offsets_;
	rec_offs_init(offsets_);

	estimate = latch_mode & BTR_ESTIMATE;
	latch_mode &= ~BTR_ESTIMATE;

	ut_ad(level != ULINT_UNDEFINED);

	bool	s_latch_by_caller;

	s_latch_by_caller = latch_mode & BTR_ALREADY_S_LATCHED;
	latch_mode &= ~BTR_ALREADY_S_LATCHED;

	lock_intention = btr_cur_get_and_clear_intention(&latch_mode);

	ut_ad(!(latch_mode & BTR_MODIFY_EXTERNAL));

	/* This function doesn't need to lock left page of the leaf page */
	if (latch_mode == BTR_SEARCH_PREV) {
		latch_mode = BTR_SEARCH_LEAF;
	} else if (latch_mode == BTR_MODIFY_PREV) {
		latch_mode = BTR_MODIFY_LEAF;
	}

	/* Store the position of the tree latch we push to mtr so that we
	know how to release it when we have latched the leaf node */

	savepoint = mtr_set_savepoint(mtr);

	switch (latch_mode) {
	case BTR_CONT_MODIFY_TREE:
	case BTR_CONT_SEARCH_TREE:
		upper_rw_latch = RW_NO_LATCH;
		break;
	case BTR_MODIFY_TREE:
		/* Most of delete-intended operations are purging.
		Free blocks and read IO bandwidth should be prior
		for them, when the history list is glowing huge. */
		if (lock_intention == BTR_INTENTION_DELETE
		    && trx_sys->rseg_history_len > BTR_CUR_FINE_HISTORY_LENGTH
		    && buf_get_n_pending_read_ios()) {
			mtr_x_lock(dict_index_get_lock(index), mtr);
		} else {
			mtr_sx_lock(dict_index_get_lock(index), mtr);
		}
		upper_rw_latch = RW_X_LATCH;
		break;
	default:
		ut_ad(!s_latch_by_caller
		      || mtr_memo_contains_flagged(mtr,
						 dict_index_get_lock(index),
						 MTR_MEMO_SX_LOCK
						 | MTR_MEMO_S_LOCK));
		if (!srv_read_only_mode) {
			if (!s_latch_by_caller) {
				/* BTR_SEARCH_TREE is intended to be used with
				BTR_ALREADY_S_LATCHED */
				ut_ad(latch_mode != BTR_SEARCH_TREE);

				mtr_s_lock(dict_index_get_lock(index), mtr);
			}
			upper_rw_latch = RW_S_LATCH;
		} else {
			upper_rw_latch = RW_NO_LATCH;
		}
	}
	root_leaf_rw_latch = btr_cur_latch_for_root_leaf(latch_mode);

	page_cursor = btr_cur_get_page_cur(cursor);
	cursor->index = index;


	page_id_t		page_id(dict_index_get_space(index),
					dict_index_get_page(index));
	const page_size_t&	page_size = dict_table_page_size(index->table);


//cgmin
	page_id_t temp_page_id(page_id.space(),page_id.page_no());
	int level_node_num;
//   temp_page_id.copy_from(page_id);

	if (root_leaf_rw_latch == RW_X_LATCH) {
		node_ptr_max_size = dict_index_node_ptr_max_size(index);
	}

	height = ULINT_UNDEFINED;

	for (;;) {
		buf_block_t*	block;
		page_t*		page;
		ulint		rw_latch;

		ut_ad(n_blocks < BTR_MAX_LEVELS);

		if (height != 0
		    && (latch_mode != BTR_MODIFY_TREE
			|| height == level)) {
			rw_latch = upper_rw_latch;
		} else {
			rw_latch = RW_NO_LATCH;
		}

		tree_savepoints[n_blocks] = mtr_set_savepoint(mtr);
		block = buf_page_get_gen(page_id, page_size, rw_latch, NULL,
					 BUF_GET, file, line, mtr);
		tree_blocks[n_blocks] = block;

		page = buf_block_get_frame(block);

//cgmin
		buf_block_t* temp_block;
//		page_t* temp_page;
		btr_cur_t* temp_cursor=btr_pcur_get_btr_cur(temp_pcur_pio);
		temp_cursor->index = index;
		page_cur_t* temp_page_cursor=btr_cur_get_page_cur(temp_cursor);

		level_node_num=1;

		temp_block = buf_page_get_gen(page_id, page_size, rw_latch, NULL,
					 BUF_GET, file, line, mtr);
//		temp_page = buf_block_get_frame(block);
		page_cur_set_before_first(temp_block, temp_page_cursor);
		while(btr_pcur_is_after_last_in_tree(temp_pcur_pio,mtr) == FALSE)
		{
			btr_pcur_move_to_next_page(temp_pcur_pio,mtr);
			level_node_num++;
		}
		if (level_node_num <= pio_t)
			level = height;

		if (height == ULINT_UNDEFINED
		    && btr_page_get_level(page, mtr) == 0
		    && rw_latch != RW_NO_LATCH
		    && rw_latch != root_leaf_rw_latch) {
			/* We should retry to get the page, because the root page
			is latched with different level as a leaf page. */
			ut_ad(root_leaf_rw_latch != RW_NO_LATCH);
			ut_ad(rw_latch == RW_S_LATCH);

			ut_ad(n_blocks == 0);
			mtr_release_block_at_savepoint(
				mtr, tree_savepoints[n_blocks],
				tree_blocks[n_blocks]);

			upper_rw_latch = root_leaf_rw_latch;
			continue;
		}

		ut_ad(fil_page_index_page_check(page));
		ut_ad(index->id == btr_page_get_index_id(page));

		if (height == ULINT_UNDEFINED) {
			/* We are in the root node */

			height = btr_page_get_level(page, mtr);
			root_height = height;
			ut_a(height >= level);
		} else {
			/* TODO: flag the index corrupted if this fails */
			ut_ad(height == btr_page_get_level(page, mtr));
		}

		if (height == level) {
			if (srv_read_only_mode) {
				btr_cur_latch_leaves(
					block, page_id, page_size,
					latch_mode, cursor, mtr);
			} else if (height == 0) {
				if (rw_latch == RW_NO_LATCH) {
					btr_cur_latch_leaves(
						block, page_id, page_size,
						latch_mode, cursor, mtr);
				}
				/* In versions <= 3.23.52 we had
				forgotten to release the tree latch
				here. If in an index scan we had to
				scan far to find a record visible to
				the current transaction, that could
				starve others waiting for the tree
				latch. */

				switch (latch_mode) {
				case BTR_MODIFY_TREE:
				case BTR_CONT_MODIFY_TREE:
				case BTR_CONT_SEARCH_TREE:
					break;
				default:
					if (!s_latch_by_caller) {
						/* Release the tree s-latch */
						mtr_release_s_latch_at_savepoint(
							mtr, savepoint,
							dict_index_get_lock(
								index));
					}

					/* release upper blocks */
					for (; n_releases < n_blocks;
					     n_releases++) {
						mtr_release_block_at_savepoint(
							mtr,
							tree_savepoints[
								n_releases],
							tree_blocks[
								n_releases]);
					}
				}
			} else { /* height != 0 */
				/* We already have the block latched. */
				ut_ad(latch_mode == BTR_SEARCH_TREE);
				ut_ad(s_latch_by_caller);
				ut_ad(upper_rw_latch == RW_S_LATCH);

				ut_ad(mtr_memo_contains(mtr, block,
							upper_rw_latch));

				if (s_latch_by_caller) {
					/* to exclude modifying tree operations
					should sx-latch the index. */
					ut_ad(mtr_memo_contains(
						mtr,
						dict_index_get_lock(index),
						MTR_MEMO_SX_LOCK));
					/* because has sx-latch of index,
					can release upper blocks. */
					for (; n_releases < n_blocks;
					     n_releases++) {
						mtr_release_block_at_savepoint(
							mtr,
							tree_savepoints[
								n_releases],
							tree_blocks[
								n_releases]);
					}
				}
			}
		}

		if (from_left) {
			page_cur_set_before_first(block, page_cursor);
		} else {
			page_cur_set_after_last(block, page_cursor);
		}

		if (height == level) {
			if (estimate) {
				btr_cur_add_path_info(cursor, height,
						      root_height);
			}

			break;
		}

		ut_ad(height > 0);

		if (from_left) {
			page_cur_move_to_next(page_cursor);
		} else {
			page_cur_move_to_prev(page_cursor);
		}

		if (estimate) {
			btr_cur_add_path_info(cursor, height, root_height);
		}

		height--;

		node_ptr = page_cur_get_rec(page_cursor);
		offsets = rec_get_offsets(node_ptr, cursor->index, offsets,
					  ULINT_UNDEFINED, &heap);

		/* If the rec is the first or last in the page for
		pessimistic delete intention, it might cause node_ptr insert
		for the upper level. We should change the intention and retry.
		*/
		if (latch_mode == BTR_MODIFY_TREE
		    && btr_cur_need_opposite_intention(
			page, lock_intention, node_ptr)) {

			ut_ad(upper_rw_latch == RW_X_LATCH);
			/* release all blocks */
			for (; n_releases <= n_blocks; n_releases++) {
				mtr_release_block_at_savepoint(
					mtr, tree_savepoints[n_releases],
					tree_blocks[n_releases]);
			}

			lock_intention = BTR_INTENTION_BOTH;

			page_id.set_page_no(dict_index_get_page(index));

			height = ULINT_UNDEFINED;

			n_blocks = 0;
			n_releases = 0;

			continue;
		}

		if (latch_mode == BTR_MODIFY_TREE
		    && !btr_cur_will_modify_tree(
				cursor->index, page, lock_intention, node_ptr,
				node_ptr_max_size, page_size, mtr)) {
			ut_ad(upper_rw_latch == RW_X_LATCH);
			ut_ad(n_releases <= n_blocks);

			/* we can release upper blocks */
			for (; n_releases < n_blocks; n_releases++) {
				if (n_releases == 0) {
					/* we should not release root page
					to pin to same block. */
					continue;
				}

				/* release unused blocks to unpin */
				mtr_release_block_at_savepoint(
					mtr, tree_savepoints[n_releases],
					tree_blocks[n_releases]);
			}
		}

		if (height == level
		    && latch_mode == BTR_MODIFY_TREE) {
			ut_ad(upper_rw_latch == RW_X_LATCH);
			/* we should sx-latch root page, if released already.
			It contains seg_header. */
			if (n_releases > 0) {
				mtr_block_sx_latch_at_savepoint(
					mtr, tree_savepoints[0],
					tree_blocks[0]);
			}

			/* x-latch the branch blocks not released yet. */
			for (ulint i = n_releases; i <= n_blocks; i++) {
				mtr_block_x_latch_at_savepoint(
					mtr, tree_savepoints[i],
					tree_blocks[i]);
			}
		}

		temp_page_id.copy_from(page_id);
		/* Go to the child node */
		page_id.set_page_no(
			btr_node_ptr_get_child_page_no(node_ptr, offsets));

		n_blocks++;
	}

	if (heap) {
		mem_heap_free(heap);
	}

	//cgmin

/*
		ulint		rw_latch;

		ut_ad(n_blocks < BTR_MAX_LEVELS);

		if (height != 0
		    && (latch_mode != BTR_MODIFY_TREE
			|| height == level)) {
			rw_latch = upper_rw_latch;
		} else {
			rw_latch = RW_NO_LATCH;
		}
*/
	if (level_node_num == pio_t)
		temp_page_id.copy_from(page_id);
	buf_block_t* temp_block;
//	page_t* temp_page;
//	page_cur_t* temp_page_cursor=*page_cursor;
//	btr_cur_t* temp_cursor=*cursor;
	btr_cur_t* temp_cursor=btr_pcur_get_btr_cur(temp_pcur_pio);
	temp_cursor->index = index;
	page_cur_t* temp_page_cursor=btr_cur_get_page_cur(temp_cursor);

	level_node_num=0;

	temp_block = buf_page_get_gen(temp_page_id, page_size, /*rw_latch*/ RW_NO_LATCH, NULL,
				 BUF_GET, file, line, mtr);
//	temp_page = buf_block_get_frame(block);
	page_cur_set_before_first(temp_block, temp_page_cursor);
//	btr_cur_get_page_cur(temp_cursor)->copy_from(temp_page_cursor);
	while(btr_pcur_is_after_last_in_tree(temp_pcur_pio,mtr) == FALSE)
	{
	buf_block_t* temp_block2;
	btr_cur_t* temp_cursor2=btr_pcur_get_btr_cur(&pcur_pio[level_node_num]);
	temp_cursor2->index = index;
	page_cur_t* temp_page_cursor2=btr_cur_get_page_cur(temp_cursor2);
	page_id_t temp_page_id2(temp_page_id.space(),temp_page_id.page_no());
//   temp_page_id2.copy_from(temp_page_id);

		int height2;
		for (height2=height;height2>0;--height2)
		{
			node_ptr = page_cur_get_rec(temp_page_cursor2);
			offsets = rec_get_offsets(node_ptr, temp_cursor2->index, offsets,
					  ULINT_UNDEFINED, &heap);
			temp_page_id2.set_page_no(btr_node_ptr_get_child_page_no(node_ptr,offsets));

			temp_block2 = buf_page_get_gen(temp_page_id2, page_size, /*rw_latch*/ RW_NO_LATCH, NULL,
				 BUF_GET, file, line, mtr);
			page_cur_set_before_first(temp_block2, temp_page_cursor2);
		}

//		btr_cur_get_page_cur(&pcur_pio[level_node_num])->copy_from(temp_page_cursor);

		page_id_pio[level_node_num] = temp_block2->page.id.page_no(); 
		btr_pcur_move_to_next_page(temp_pcur_pio,mtr);
		temp_block = btr_pcur_get_block(temp_pcur_pio);
		temp_page_id.copy_from(temp_block->page.id);

		level_node_num++;
	}


//cgmin
DBUG_VOID_RETURN;

}
#endif
//#ifndef cgmin_pio
//#define cgmin_pio
UNIV_INLINE
void prepare_pio(int* pio_t,btr_pcur_t *pcur_pio,ulint *page_id_pio,
	bool		from_left,	/*!< in: true if open to the low end,
					false if to the high end */
	dict_index_t*	index,		/*!< in: index */
	ulint		latch_mode,	/*!< in: latch mode */
	btr_pcur_t*	pcur,		/*!< in/out: cursor */
	bool		init_pcur,	/*!< in: whether to initialize pcur */
	ulint		level,		/*!< in: level to search for
					(0=leaf) */
	mtr_t*		mtr)		/*!< in/out: mini-transaction */
{
	int i;
	btr_cur_t* cur[128];

	mtr->start();

	for (i=0;i<*pio_t;++i)
	{
		pcur_pio[i].latch_mode = BTR_LATCH_MODE_WITHOUT_FLAGS(latch_mode);
		pcur_pio[i].search_mode = from_left ? PAGE_CUR_G : PAGE_CUR_L;

		btr_pcur_init(&pcur_pio[i]);

		btr_pcur_copy_stored_position(&pcur_pio[i],pcur);

		cur[i] = btr_pcur_get_btr_cur(&pcur_pio[i]);
//		btr_cur_open_at_rnd_pos(index,latch_mode,btr_pcur_get_btr_cur(&pcur_pio[i]),mtr);			
	}



	btr_cur_open_pio(pio_t,page_id_pio,index,latch_mode,cur,mtr);

	for (i=0;i<*pio_t;++i)
	{
		pcur_pio[i].pos_state = BTR_PCUR_IS_POSITIONED;
		pcur_pio[i].old_stored = false;
		pcur_pio[i].trx_if_known = NULL;

		pcur_pio[i].latch_mode = RW_S_LATCH;//???

		btr_pcur_get_btr_cur(&pcur_pio[i])->index = index;///???
//	printf("%lu %lu\n",(ulint)btr_pcur_get_block(&pcur_pio[i])->page.id.page_no(),(ulint)page_id_pio);
//	printf("%d\n",(int)btr_pcur_is_after_last_in_tree(&pcur_pio[i],mtr));
	}
#if 0
	int i;
	for (i=0;i<pio_t;++i)
	{
		pcur_pio[i].latch_mode = BTR_LATCH_MODE_WITHOUT_FLAGS(latch_mode);
		pcur_pio[i].search_mode = from_left ? PAGE_CUR_G : PAGE_CUR_L;

		btr_pcur_init(&pcur_pio[i]);

		page_id_pio[i] = 0;

	}


	pcur->latch_mode = BTR_LATCH_MODE_WITHOUT_FLAGS(latch_mode);

	pcur->search_mode = from_left ? PAGE_CUR_G : PAGE_CUR_L;

	if (init_pcur) {
		btr_pcur_init(pcur);
	}
/*
	set_pcur_pos_pio(pio_t,pcur_pio,page_id_pio,pcur,
			from_left, index, latch_mode,
			btr_pcur_get_btr_cur(pcur)
			, level, mtr);
*/
	pcur->pos_state = BTR_PCUR_IS_POSITIONED;

	pcur->old_stored = false;

	pcur->trx_if_known = NULL;

	for (i=0;i<pio_t;++i)
	{
		pcur->pos_state = BTR_PCUR_IS_POSITIONED;
		pcur->old_stored = false;
		pcur->trx_if_known = NULL;
	}
#endif
}
struct data_pio
{
	btr_pcur_t* pcur_pio;
	ulint page_id_pio;
	mtr_t* mtr;
};

UNIV_INLINE
void *ptf_pio(void *data)
{

	btr_pcur_t* cursor = ((data_pio*)data)->pcur_pio;
	ulint page_id_pio = ((data_pio*)data)->page_id_pio;
	mtr_t* mtr = ((data_pio*)data)->mtr;

printf("pio s %lu\n",page_id_pio);

	ut_ad(cursor->pos_state == BTR_PCUR_IS_POSITIONED);
	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);

	cursor->old_stored = false;

//	printf("%lu %lu\n",(ulint)btr_pcur_get_block(cursor)->page.id.page_no(),(ulint)page_id_pio);
//	printf("%d\n",(int)btr_pcur_is_after_last_in_tree(cursor,mtr));

/*
	if 	(btr_pcur_is_after_last_in_tree(cursor,mtr) == false)
		pthread_exit(NULL);

if (btr_pcur_get_block(cursor)->page.id.page_no() == (ulint)page_id_pio)
	pthread_exit(NULL);
*/
	while (btr_pcur_is_after_last_in_tree(cursor,mtr) == false &&
// (ulint)btr_page_get_next(btr_pcur_get_page(cursor),mtr) != (ulint)page_id_pio)
(ulint)btr_pcur_get_block(cursor)->page.id.page_no() != (ulint)page_id_pio)
	{

//printf("   %lu %lu\n",(ulint)btr_pcur_get_block(cursor)->page.id.page_no(),(ulint)page_id_pio);
		btr_pcur_move_to_next_page(cursor, mtr);
		page_cur_set_after_last(btr_pcur_get_block(cursor),btr_pcur_get_page_cur(cursor));



	}
	btr_leaf_page_release(btr_pcur_get_block(cursor), cursor->latch_mode, mtr);
//	btr_leaf_page_release(btr_pcur_get_block(&pcur_pio[i]), pcur_pio[i].latch_mode, mtr);


mtr->commit();
btr_pcur_close(cursor);


printf("pio f %lu\n",page_id_pio);
	pthread_exit(NULL);
}
UNIV_INLINE
void do_pio(int *pio_t,btr_pcur_t *pcur_pio,ulint *page_id_pio,mtr_t* mtr_pio)
{
	int i;
	pthread_t pthread[128];
	data_pio data[128];

//0-1
	for (i=0;i<*pio_t;++i)
	{
//		if (page_id_pio[i] == 0)
//			continue;
mtr_pio[i].start();
		data[i].pcur_pio=&pcur_pio[i];
		data[i].mtr = &mtr_pio[i];
		if (i == *pio_t-1)
			data[i].page_id_pio = 0;
		else
			data[i].page_id_pio = page_id_pio[i+1];
//	printf("%lu %lu\n",(ulint)btr_pcur_get_block(&pcur_pio[i])->page.id.page_no(),(ulint)data[i].page_id_pio);
//	printf("%d\n",(int)btr_pcur_is_after_last_in_tree(&pcur_pio[i],mtr));
//		data_pio *dp = &data[i];
		pthread_create(&pthread[i],NULL,&ptf_pio,(void*)&(data[i]));
//		pthread_create(&pthread[i],NULL,&ptf_pio,(void*)dp);
//			ptf_pio(&pcur_pio[i],-1);
//		else
//			ptf_pio(&pcur_pio[i],page_id_pio[i+1]);
	}




/*
	for (i=0;i<*pio_t;++i)
{
		pthread_join(pthread[i],NULL);
mtr_pio[i].commit();
}
*/





}
UNIV_INLINE
void close_pio(int* pio_t,btr_pcur_t *pcur_pio,mtr_t* mtr)
{
//printf("x0\n");
/*
	for (i=0;i<*pio_t;++i)
	{

		btr_leaf_page_release(btr_pcur_get_block(&pcur_pio[i]), pcur_pio[i].latch_mode, mtr);
}
*/
//printf("x0.5\n");



/*
int i;
for (i=0;i<*pio_t;++i)
{
		btr_pcur_close(&pcur_pio[i]);
	
//btr_leaf_page_release(btr_pcur_get_block(&pcur), pcur.latch_mode, mtr)
//or by committing the mini-transaction right after btr_pcur_close().


	}
*/






//printf("x1\n");
	mtr->commit();
//	mtr->start();
//printf("x2\n");
//	btr_pcur_close(pcur);
}
//#endif
/*****************************************************************//**
Opens a persistent cursor at either end of an index. */
UNIV_INLINE
void
btr_pcur_open_at_index_side(
/*========================*/
	bool		from_left,	/*!< in: true if open to the low end,
					false if to the high end */
	dict_index_t*	index,		/*!< in: index */
	ulint		latch_mode,	/*!< in: latch mode */
	btr_pcur_t*	pcur,		/*!< in/out: cursor */
	bool		init_pcur,	/*!< in: whether to initialize pcur */
	ulint		level,		/*!< in: level to search for
					(0=leaf) */
	mtr_t*		mtr)		/*!< in/out: mini-transaction */
{
	pcur->latch_mode = BTR_LATCH_MODE_WITHOUT_FLAGS(latch_mode);

	pcur->search_mode = from_left ? PAGE_CUR_G : PAGE_CUR_L;

	if (init_pcur) {
		btr_pcur_init(pcur);
	}

	if (dict_table_is_intrinsic(index->table)) {
		btr_cur_open_at_index_side_with_no_latch(
			from_left, index,
			btr_pcur_get_btr_cur(pcur), level, mtr);
	} else {
		btr_cur_open_at_index_side(
			from_left, index, latch_mode,
			btr_pcur_get_btr_cur(pcur), level, mtr);
	}
	pcur->pos_state = BTR_PCUR_IS_POSITIONED;

	pcur->old_stored = false;

	pcur->trx_if_known = NULL;
}

/**********************************************************************//**
Positions a cursor at a randomly chosen position within a B-tree.
@return true if the index is available and we have put the cursor, false
if the index is unavailable */
UNIV_INLINE
bool
btr_pcur_open_at_rnd_pos_func(
/*==========================*/
	dict_index_t*	index,		/*!< in: index */
	ulint		latch_mode,	/*!< in: BTR_SEARCH_LEAF, ... */
	btr_pcur_t*	cursor,		/*!< in/out: B-tree pcur */
	const char*	file,		/*!< in: file name */
	ulint		line,		/*!< in: line where called */
	mtr_t*		mtr)		/*!< in: mtr */
{
	/* Initialize the cursor */

	cursor->latch_mode = latch_mode;
	cursor->search_mode = PAGE_CUR_G;

	btr_pcur_init(cursor);

	bool	available;

	available = btr_cur_open_at_rnd_pos_func(index, latch_mode,
						 btr_pcur_get_btr_cur(cursor),
						 file, line, mtr);
	cursor->pos_state = BTR_PCUR_IS_POSITIONED;
	cursor->old_stored = false;

	cursor->trx_if_known = NULL;

	return(available);
}

/**************************************************************//**
Frees the possible memory heap of a persistent cursor and sets the latch
mode of the persistent cursor to BTR_NO_LATCHES.
WARNING: this function does not release the latch on the page where the
cursor is currently positioned. The latch is acquired by the
"move to next/previous" family of functions. Since recursive shared locks
are not allowed, you must take care (if using the cursor in S-mode) to
manually release the latch by either calling
btr_leaf_page_release(btr_pcur_get_block(&pcur), pcur.latch_mode, mtr)
or by committing the mini-transaction right after btr_pcur_close().
A subsequent attempt to crawl the same page in the same mtr would cause
an assertion failure. */
UNIV_INLINE
void
btr_pcur_close(
/*===========*/
	btr_pcur_t*	cursor)	/*!< in: persistent cursor */
{
	ut_free(cursor->old_rec_buf);

	if (cursor->btr_cur.rtr_info) {
		rtr_clean_rtr_info(cursor->btr_cur.rtr_info, true);
		cursor->btr_cur.rtr_info = NULL;
	}

	cursor->old_rec = NULL;
	cursor->old_rec_buf = NULL;
	cursor->btr_cur.page_cur.rec = NULL;
	cursor->btr_cur.page_cur.block = NULL;

	cursor->old_rec = NULL;
	cursor->old_stored = false;

	cursor->latch_mode = BTR_NO_LATCHES;
	cursor->pos_state = BTR_PCUR_NOT_POSITIONED;

	cursor->trx_if_known = NULL;
}

/*********************************************************//**
Moves the persistent cursor to the infimum record on the same page. */
UNIV_INLINE
void
btr_pcur_move_before_first_on_page(
/*===============================*/
	btr_pcur_t*	cursor) /*!< in/out: persistent cursor */
{
	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);

	page_cur_set_before_first(btr_pcur_get_block(cursor),
		btr_pcur_get_page_cur(cursor));

	cursor->old_stored = false;
}
