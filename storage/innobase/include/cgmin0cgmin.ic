UNIV_INLINE
void prepare_pio(int pio_t,btr_pcur_t *pcur_pio,ulint *page_id_pio,
	bool		from_left,	/*!< in: true if open to the low end,
					false if to the high end */
	dict_index_t*	index,		/*!< in: index */
	ulint		latch_mode,	/*!< in: latch mode */
	btr_pcur_t*	pcur,		/*!< in/out: cursor */
	bool		init_pcur,	/*!< in: whether to initialize pcur */
	ulint		level,		/*!< in: level to search for
					(0=leaf) */
	mtr_t*		mtr)		/*!< in/out: mini-transaction */
{

	int i;
	for (i=0;i<pio_t;++i)
	{
		pcur_pio[i].latch_mode = BTR_LATCH_MODE_WITHOUT_FLAGS(latch_mode);
		pcur_pio[i].search_mode = from_left ? PAGE_CUR_G : PAGE_CUR_L;

		btr_pcur_init(&pcur_pio[i]);

		page_id_pio[i] = 0;

	}


	pcur->latch_mode = BTR_LATCH_MODE_WITHOUT_FLAGS(latch_mode);

	pcur->search_mode = from_left ? PAGE_CUR_G : PAGE_CUR_L;

	if (init_pcur) {
		btr_pcur_init(pcur);
	}

	set_pcur_pos_pio(pio_t,pcur_pio,page_id_pio,pcur,
			from_left, index, latch_mode,
			btr_pcur_get_btr_cur(pcur)
			, level, mtr);

	pcur->pos_state = BTR_PCUR_IS_POSITIONED;

	pcur->old_stored = false;

	pcur->trx_if_known = NULL;

	for (i=0;i<pio_t;++i)
	{
		pcur->pos_state = BTR_PCUR_IS_POSITIONED;
		pcur->old_stored = false;
		pcur->trx_if_known = NULL;
	}

}
struct data_pio
{
	btr_pcur_t* pcur_pio;
	ulint page_id_pio;
	mtr_t* mtr;
};

//void ptf_pio(btr_pcur_t* pcur_pio,int page_id_pio)
//void ptf_pio(data_pio *data)
UNIV_INLINE
void *ptf_pio(void *data)
{

	btr_pcur_t* cursor = ((data_pio*)data)->pcur_pio;
	ulint page_id_pio = ((data_pio*)data)->page_id_pio;
	mtr_t* mtr = ((data_pio*)data)->mtr;

	ut_ad(cursor->pos_state == BTR_PCUR_IS_POSITIONED);
	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);

	cursor->old_stored = false;

	while (btr_pcur_is_after_last_in_tree(cursor,mtr) && btr_pcur_get_block(cursor)->page.id.page_no() != (ulint)page_id_pio) {

		btr_pcur_move_to_next_page(cursor, mtr);

	}
	pthread_exit(NULL);
}
UNIV_INLINE
void do_pio(int pio_t,btr_pcur_t *pcur_pio,ulint *page_id_pio,mtr_t* mtr)
{
	int i;
	pthread_t pthread[128];
	data_pio data[128];
	for (i=0;i<pio_t;++i)
	{
		data[i].pcur_pio=&pcur_pio[i];
		data[i].mtr = mtr;
		if (i == pio_t-1)
			data[i].page_id_pio = 0;
		else
			data[i].page_id_pio = page_id_pio[i+1];
//		data_pio *dp = &data[i];
		pthread_create(&pthread[i],NULL,&ptf_pio,(void*)&(data[i]));
//		pthread_create(&pthread[i],NULL,&ptf_pio,(void*)dp);
//			ptf_pio(&pcur_pio[i],-1);
//		else
//			ptf_pio(&pcur_pio[i],page_id_pio[i+1]);
	}
	for (i=0;i<pio_t;++i)
		pthread_join(pthread[i],NULL);
}
UNIV_INLINE
void close_pio(int pio_t,btr_pcur_t *pcur_pio,btr_pcur_t *pcur)
{
	int i;
	for (i=0;i<pio_t;++i)
		btr_pcur_close(&pcur_pio[i]);
	btr_pcur_close(pcur);
}
//#endif

